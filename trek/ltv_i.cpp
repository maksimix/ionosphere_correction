#include <math.h>
#include <float.h>
#include "mytrek.h"

void MyTrek::ltv_i(double *x,
                   double *y00,
                   double *f00,
                   double *yp10,
                   double *fp10,
                   double *h,
                   int     n,
                   double e,
                   double eps,
                   int     n1,
                   int     n2,
                   int     *ini,
                   double *r)
/***************************************************************/
/* Функция осуществляет шаг интегрирования дифференциальных    */
/* уравнений методом типа Коуэлла.                             */
/*                                                             */
/* x    - значение аргумента;                                  */
/* y00  - начальное значение вектор-функции;                   */
/* f00  - значения производных в начальной точкеж              */
/* yp10 - значение вектор-функции после очередного шагаж       */
/* fp10 - значения производных после очередного шага;          */
/* h    - шаг интегрирования;                                  */
/* n    - число уравнений;                                     */
/* e    - параметр определяющий увеличение шага;               */
/* eps  - локальная точность интегрирования;                   */
/* n1 и n2 - определяют, какие уравнения участвуют в оценке    */
/*           локальной погрешности;                            */
/* r    - локальная погрешность на шаге;                       */
/*                                                             */
/* ini - 0, при первом обращении к функции для инициализации   */
/*          процесса вычислений.                               */
/*                                                             */
/*VGG 18.05.93                                                 */
/***************************************************************/
{
  double y[22],fm10[22],fm05[22],fp05[22],fp15[22],
         r1,x0,h1;
  const double eps0=.1*DBL_MAX;
  int      let;

      let=1;
      *r=DBL_MAX;

      if (!(*ini))
        {
          func(*x,y00,fm10,n);
          h1=.5**h;
          ltv(x,y00,fm10,y,fm05,&h1,n,e,eps,n1,n2,&r1);
          if (h1>.5**h)
            h1 *=.5;
          *h=2.*h1;
          ltv(x,y,fm05,y00,f00,&h1,n,.0,eps0,n1,n2,&r1);
          x0=*x;
          ltv(&x0,y00,f00,y,fp05,&h1,n,.0,eps0,n1,n2,&r1);
          (*ini)++;
        }

      while(*r>eps)
        {
          for(int i=0; i<n; i++)
            *(yp10+i)=*(y00+i)+*h*(-*(fm10+i)+4.**(fm05+i)-
                                  5.**(f00+i)+8.**(fp05+i))/6.;
          x0=*x+*h;

          func(x0,yp10,fp10,n);

          for(int i=0; i<n; i++)
            *(y+i)=*(y00+i)+3.**h*(-*(fm05+i)+5.**(f00+i)-
                                      3.**(fp05+i)+7.**(fp10+i))/16.;
          x0=*x+1.5**h;

          func(x0,y,fp15,n);

          *r=.0;
          for(int i=0; i<n; i++)
            {
              r1=*(y00+i)+*h*(-*(fm05+i)+34.**(f00+i)+114.**(fp05+i)+
                             34.**(fp10+i)-*(fp15+i))/180.;
              if (i>=n1 && i<=n2)
                  *r=(*r>fabs(r1-*(yp10+i)))? *r : fabs(r1-*(yp10+i));

              *(yp10+i)=r1;
            }

          x0=*x+*h;

          if (*r>eps)
            {
              *h *=.5;
              for(int i=0; i<n; i++)
                *(fm10+i)=*(fm05+i);
              x0=*x;
              h1=-.5**h;
              ltv(&x0,y00,f00,y,fm05,&h1,n,.0,eps0,n1,n2,&r1);
              x0=*x;
              h1=-h1;
              ltv(&x0,y00,f00,y,fp05,&h1,n,.0,eps0,n1,n2,&r1);
              let=0;
            }
        }

      *x +=*h;

      if (*r<e && let)
        {
          for(int i=0; i<n; i++)
            *(fm05+i)=*(f00+i);
          x0=*x;
          ltv(&x0,yp10,fp10,y,fp05,h,n,.0,eps0,n1,n2,&r1);
          *h *=2.;
        }
      else
        for(int i=0; i<n; i++)
          {
            *(fm10+i)=*(f00+i);
            *(fm05+i)=*(fp05+i);
            *(fp05+i)=*(fp15+i);
          }

      return;
}

void MyTrek::ltv(double *x,
                 double *y0,
                 double *f0,
                 double *y1,
                 double *f1,
                 double *h,
                 int     n,
                 double e,
                 double eps,
                 int     n1,
                 int     n2,
                 double *r)
/********************************************************************/
/*     ФУНКЦИЯ ОСУЩЕСТВЛЯЕТ ОДИН ШАГ ИНТЕГРИРОВАНИЯ СИСТЕМЫ         */
/*     n ДИФ. УРАВНЕНИЙ ПЕРВОГО ПОРЯДКА МЕТОДОМ ЧЕТВЕРТОГО ПОРЯДКА  */
/*     ПУТЕМ ПОСЛЕДОВАТЕЛЬНОГО УВЕЛИЧЕНИЯ ТОЧНОСТИ РЕЗУЛЬТАТА.      */
/*                                                                  */
/* x    -НЕЗАВИСИМАЯ ПЕРЕМЕННАЯ;                                    */
/* y0,f0 -НАЧАЛЬНЫЕ ЗНАЧЕНИЯ ФУНКЦИИ И ПРОИЗВОДНЫХ;                 */
/* y1,f1 -КОНЕЧНЫЕ ЗНАЧЕНИЯ;                                        */
/* n    -ЧИСЛО УРАВНЕНИЙ;                                           */
/* h    -ШАГ ИНТЕГРИРОВАНИЯ, ОН ЖЕ ПОДБИРАЕТСЯ ПРОЦЕДУРОЙ ПО        */
/*       ПАРАМЕТРАМ e И eps, ТАК ЧТО ЛОКАЛЬНАЯ ОШИБКА СТАНОВИТСЯ    */
/*       БОЛЬШЕ e И МЕНЬШЕ eps;                                     */
/* func -УКАЗАТЕЛЬ НА ФУНКЦИЮ, ВЫЧИСЛЯЮЩУЮ ПРОИЗВОДНЫЕ.             */
/*                                                                  */
/*VGG  21.04.93                                                     */
/********************************************************************/
{
  double y2[22],f2[22],r1,x0;
  int       i,let;

  let=1;
  *r=DBL_MAX;

  while (*r>eps)
    {
      for(i=0; i<n; i++)
        *(y2+i)=*(y0+i)+*h**(f0+i)/3.;
      x0=*x+*h/3.;

      func(x0,y2,f2,n);

      for(i=0; i<n; i++)
        *(y2+i)=*(y0+i)+*h*(*(f0+i)+*(f2+i))/6.;

      func(x0,y2,f2,n);

      for(i=0; i<n; i++)
        *(y2+i)=*(y0+i)+*h*(*(f0+i)+3.**(f2+i))/8.;
      x0=*x+*h*.5;

      func(x0,y2,f1,n);

      for(i=0; i<n; i++)
        *(y2+i)=*(y0+i)+*h*(*(f0+i)-3.**(f2+i)+4.**(f1+i))*.5;
      x0=*x+*h;

      func(x0,y2,f2,n);

      *r=.0;
      for(i=0; i<n; i++)
        {
          *(y1+i)=*(y0+i)+*h*(*(f0+i)+4.**(f1+i)+*(f2+i))/6.;
          if (i>=n1 && i<=n2)
            {
              r1=fabs(*(y1+i)-*(y2+i));
              *r=(*r>r1)? *r : r1;
            }
          *(f1+i)=*(f2+i);
        }

      if (*r>eps)
        {
          *h *=.5;
          let=0;
        }
    }

  if (*r<e && let) *h *=2.;

  *x=x0;

  return;
}
